1.setState 只在合成事件和钩子函数中是“异步”的，在原生事件和setTimeout 中都是同步的。
2.setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形成了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。
3.setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次setState，setState的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时setState多个不同的值，在更新时会对其进行合并批量更新。
4.这里「合成事件」和「钩子函数」是 react 由控制的，所以 react 可以在这些地方进行优化（优化就是指对多次更新 进行批量操作啦；而因为有批量操作，所以 setState 不能立刻反映到 this.state 中）。而 setTimeout 以及原生事件由用户控制，react 也就没办法优化这些场景了.批量更新的策略是基于"异步"之上的，在setTimeout和原生事件中是没有的